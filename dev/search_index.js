var documenterSearchIndex = {"docs":
[{"location":"dev_docs_for_search/#Documenter.jl-Search-System-Developer-Documentation","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"","category":"section"},{"location":"dev_docs_for_search/#Overview","page":"Documenter.jl Search System Developer Documentation","title":"Overview","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The search system in Documenter.jl provides full-text search functionality for generated documentation sites. It consists of two main components: a Julia-based index generation system that runs during documentation build time, and a JavaScript-based client-side search interface that provides real-time search functionality to users.","category":"page"},{"location":"dev_docs_for_search/#Architecture","page":"Documenter.jl Search System Developer Documentation","title":"Architecture","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The search system follows a build-time indexing and client-side search architecture:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Build-time Index Generation (src/html/HTMLWriter.jl)\nClient-side Search Interface (assets/html/js/search.js)\nWeb Worker Processing (for performance optimization)","category":"page"},{"location":"dev_docs_for_search/#Index-Generation-Process","page":"Documenter.jl Search System Developer Documentation","title":"Index Generation Process","text":"","category":"section"},{"location":"dev_docs_for_search/#1.-SearchRecord-Structure","page":"Documenter.jl Search System Developer Documentation","title":"1. SearchRecord Structure","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The core data structure is the SearchRecord struct defined in src/html/HTMLWriter.jl:656:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"struct SearchRecord\n    src::String          # URL/path to the document\n    page::Documenter.Page # Reference to the page object\n    fragment::String     # URL fragment (for anchored content)\n    category::String     # Content category (page, section, docstring, etc.)\n    title::String        # Display title for search results\n    page_title::String   # Title of the containing page\n    text::String         # Searchable text content\nend","category":"page"},{"location":"dev_docs_for_search/#2.-Index-Generation-Pipeline","page":"Documenter.jl Search System Developer Documentation","title":"2. Index Generation Pipeline","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The search index is built during HTML generation through the following process:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Content Traversal: The system traverses each page's markdown AST (src/html/HTMLWriter.jl:1752)\nRecord Creation: For each content node, a SearchRecord is created using the searchrecord() function (src/html/HTMLWriter.jl:748)\nContent Categorization: Different content types are categorized:\nPages: category = \"page\"\nSections/Headers: category = \"section\" (src/html/HTMLWriter.jl:728)\nDocstrings: category = \"docstring\" \nOther content: category = \"page\"\nText Extraction: Content is flattened into searchable text using the mdflatten() function\nDeduplication: Records with the same location are merged to reduce index size\nSerialization: The final index is serialized to JavaScript format","category":"page"},{"location":"dev_docs_for_search/#3.-Index-Output","page":"Documenter.jl Search System Developer Documentation","title":"3. Index Output","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The search index is written to search_index.js in the following format:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"var documenterSearchIndex = {\"docs\": [\n  {\n    \"location\": \"page.html#fragment\",\n    \"page\": \"Page Title\", \n    \"title\": \"Content Title\",\n    \"category\": \"section\",\n    \"text\": \"Searchable content text...\"\n  }\n  // ... more records\n]}","category":"page"},{"location":"dev_docs_for_search/#4.-Content-Filtering","page":"Documenter.jl Search System Developer Documentation","title":"4. Content Filtering","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Certain content types are excluded from indexing (src/html/HTMLWriter.jl:743):","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"MetaNode - Metadata blocks\nDocsNodesBlock - Documentation node blocks  \nSetupNode - Setup blocks","category":"page"},{"location":"dev_docs_for_search/#Client-Side-Search-Implementation","page":"Documenter.jl Search System Developer Documentation","title":"Client-Side Search Implementation","text":"","category":"section"},{"location":"dev_docs_for_search/#1.-Search-Architecture","page":"Documenter.jl Search System Developer Documentation","title":"1. Search Architecture","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The client-side search uses a Web Worker architecture for performance:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Main Thread: Handles UI interactions, filters, and DOM updates\nWeb Worker: Performs search operations using MiniSearch library","category":"page"},{"location":"dev_docs_for_search/#2.-MiniSearch-Configuration","page":"Documenter.jl Search System Developer Documentation","title":"2. MiniSearch Configuration","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The search system uses MiniSearch with the following configuration (assets/html/js/search.js:189):","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"let index = new MiniSearch({\n  fields: [\"title\", \"text\"],           // Fields to index\n  storeFields: [\"location\", \"title\", \"text\", \"category\", \"page\"], // Fields to return\n  processTerm: (term) => {\n    // Custom term processing with stop words removal\n    // Preserves Julia-specific symbols (@, !)\n  },\n  tokenize: (string) => string.split(/[\\s\\-\\.]+/), // Custom tokenizer\n  searchOptions: {\n    prefix: true,       // Enable prefix matching\n    boost: { title: 100 }, // Boost title matches\n    fuzzy: 2           // Enable fuzzy matching\n  }\n});","category":"page"},{"location":"dev_docs_for_search/#3.-Stop-Words","page":"Documenter.jl Search System Developer Documentation","title":"3. Stop Words","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The system includes a comprehensive stop words list (assets/html/js/search.js:81) derived from Lunr 2.1.3, with Julia-specific exclusions to preserve important Julia keywords.","category":"page"},{"location":"dev_docs_for_search/#4.-Search-Workflow","page":"Documenter.jl Search System Developer Documentation","title":"4. Search Workflow","text":"","category":"section"},{"location":"dev_docs_for_search/#Main-Thread-Process:","page":"Documenter.jl Search System Developer Documentation","title":"Main Thread Process:","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Input Handling: User types in search box → triggers input event\nWorker Communication: If worker not busy → launch search via postMessage\nResult Processing: Worker returns results → filter and display\nURL Updates: Search queries and filters update browser URL","category":"page"},{"location":"dev_docs_for_search/#Web-Worker-Process:","page":"Documenter.jl Search System Developer Documentation","title":"Web Worker Process:","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Query Processing: Receive search query from main thread\nSearch Execution: Run MiniSearch with scoring threshold (score ≥ 1)\nResult Generation: Create HTML for up to 200 results per category\nReturn Results: Send formatted results back to main thread","category":"page"},{"location":"dev_docs_for_search/#5.-Result-Rendering","page":"Documenter.jl Search System Developer Documentation","title":"5. Result Rendering","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Search results include (assets/html/js/search.js:264):","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Title: Highlighted with category badge\nSnippet: Text excerpt with search term highlighting\nLink: Direct link to content location\nContext: Page information and location path","category":"page"},{"location":"dev_docs_for_search/#6.-Filtering-System","page":"Documenter.jl Search System Developer Documentation","title":"6. Filtering System","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The search interface provides category-based filtering:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Filters are generated dynamically from available categories\nUsers can filter by content type (page, section, docstring, etc.)\nFiltering is applied client-side for immediate response","category":"page"},{"location":"dev_docs_for_search/#Performance-Optimizations","page":"Documenter.jl Search System Developer Documentation","title":"Performance Optimizations","text":"","category":"section"},{"location":"dev_docs_for_search/#1.-Web-Worker-Usage","page":"Documenter.jl Search System Developer Documentation","title":"1. Web Worker Usage","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Offloads search computation from main thread\nMaintains UI responsiveness during search operations\nHandles concurrent search requests efficiently","category":"page"},{"location":"dev_docs_for_search/#2.-Result-Limiting","page":"Documenter.jl Search System Developer Documentation","title":"2. Result Limiting","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Pre-filters to 200 unique results per category\nPrevents excessive DOM manipulation\nReduces memory usage for large documentation sites","category":"page"},{"location":"dev_docs_for_search/#3.-Index-Deduplication","page":"Documenter.jl Search System Developer Documentation","title":"3. Index Deduplication","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Merges duplicate entries at build time\nReduces index size and network transfer\nImproves search performance","category":"page"},{"location":"dev_docs_for_search/#4.-Progressive-Loading","page":"Documenter.jl Search System Developer Documentation","title":"4. Progressive Loading","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Search index loads asynchronously\nFallback handling for missing dependencies\nGraceful degradation without search functionality","category":"page"},{"location":"dev_docs_for_search/#Configuration-Options","page":"Documenter.jl Search System Developer Documentation","title":"Configuration Options","text":"","category":"section"},{"location":"dev_docs_for_search/#Build-Time-Settings","page":"Documenter.jl Search System Developer Documentation","title":"Build-Time Settings","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"# In make.jl\nmakedocs(\n    # ... other options\n    format = Documenter.HTML(\n        # Search-related settings\n        search_size_threshold_warn = 200_000  # Warn if index > 200KB\n    )\n)","category":"page"},{"location":"dev_docs_for_search/#Size-Thresholds","page":"Documenter.jl Search System Developer Documentation","title":"Size Thresholds","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Warning threshold: 200KB by default\nLarge indices may impact page load performance\nAutomatic warnings during build process","category":"page"},{"location":"dev_docs_for_search/#Integration-Points","page":"Documenter.jl Search System Developer Documentation","title":"Integration Points","text":"","category":"section"},{"location":"dev_docs_for_search/#1.-Asset-Management","page":"Documenter.jl Search System Developer Documentation","title":"1. Asset Management","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Search JavaScript is bundled with other Documenter assets\nMiniSearch library loaded from CDN (__MINISEARCH_VERSION__ placeholder)\nDependencies managed through JSDependencies.jl","category":"page"},{"location":"dev_docs_for_search/#2.-Theme-Integration","page":"Documenter.jl Search System Developer Documentation","title":"2. Theme Integration","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Search UI styled using Bulma CSS framework\nResponsive design for mobile devices\nDark/light theme support","category":"page"},{"location":"dev_docs_for_search/#3.-URL-Routing","page":"Documenter.jl Search System Developer Documentation","title":"3. URL Routing","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Search queries persist in URL parameters (?q=search_term)\nFilter states maintained in URL (?filter=section)\nBrowser history integration for navigation","category":"page"},{"location":"dev_docs_for_search/#Testing-and-Benchmarking","page":"Documenter.jl Search System Developer Documentation","title":"Testing and Benchmarking","text":"","category":"section"},{"location":"dev_docs_for_search/#1.-Test-Infrastructure","page":"Documenter.jl Search System Developer Documentation","title":"1. Test Infrastructure","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Real search testing: test/search/real_search.jl\nBenchmark suite: test/search/run_benchmarks.jl\nEdge case testing: test/search_edge_cases/","category":"page"},{"location":"dev_docs_for_search/#2.-Search-Validation","page":"Documenter.jl Search System Developer Documentation","title":"2. Search Validation","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The testing system provides:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Index generation validation\nSearch result accuracy verification  \nPerformance benchmarking capabilities\nEdge case handling verification","category":"page"},{"location":"dev_docs_for_search/#Troubleshooting","page":"Documenter.jl Search System Developer Documentation","title":"Troubleshooting","text":"","category":"section"},{"location":"dev_docs_for_search/#Common-Issues","page":"Documenter.jl Search System Developer Documentation","title":"Common Issues","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Missing Search Functionality\nVerify search_index.js exists in build output\nCheck browser console for JavaScript errors\nEnsure MiniSearch library loads successfully\nPoor Search Results\nReview content categorization in source\nCheck stop words configuration\nVerify text extraction from markdown\nPerformance Issues\nMonitor search index size (check build warnings)\nConsider content exclusion for large sites\nReview result limiting configuration","category":"page"},{"location":"dev_docs_for_search/#Debug-Tools","page":"Documenter.jl Search System Developer Documentation","title":"Debug Tools","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Browser developer tools for client-side debugging\nJulia logging for index generation issues\nNetwork tab for asset loading verification","category":"page"},{"location":"dev_docs_for_search/#Extension-Points","page":"Documenter.jl Search System Developer Documentation","title":"Extension Points","text":"","category":"section"},{"location":"dev_docs_for_search/#1.-Custom-Categories","page":"Documenter.jl Search System Developer Documentation","title":"1. Custom Categories","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Extend SearchRecord creation to add custom content categories:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"function SearchRecord(ctx, navnode, node::Node, element::CustomElement)\n    return SearchRecord(ctx, navnode; \n        category = \"custom_type\",\n        title = extract_custom_title(element),\n        text = extract_custom_text(element)\n    )\nend","category":"page"},{"location":"dev_docs_for_search/#2.-Enhanced-Filtering","page":"Documenter.jl Search System Developer Documentation","title":"2. Enhanced Filtering","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Add custom filters by extending the JavaScript filter generation:","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"function make_modal_body_filters() {\n    // Add custom filter logic\n    // Extend category-based filtering\n}","category":"page"},{"location":"dev_docs_for_search/#3.-Result-Customization","page":"Documenter.jl Search System Developer Documentation","title":"3. Result Customization","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"Modify result rendering in make_search_result() function for custom display formats.","category":"page"},{"location":"dev_docs_for_search/#Conclusion","page":"Documenter.jl Search System Developer Documentation","title":"Conclusion","text":"","category":"section"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The Documenter.jl search system provides a robust, performant solution for documentation search through its dual-architecture approach. The build-time indexing ensures comprehensive content coverage, while the client-side Web Worker implementation maintains excellent user experience even with large documentation sites.","category":"page"},{"location":"dev_docs_for_search/","page":"Documenter.jl Search System Developer Documentation","title":"Documenter.jl Search System Developer Documentation","text":"The system is designed to be extensible and maintainable, with clear separation of concerns between index generation and search functionality. Performance considerations are built-in at multiple levels, from index optimization to UI responsiveness.","category":"page"},{"location":"conclusion/#Conclusion","page":"Conclusion","title":"Conclusion","text":"","category":"section"},{"location":"conclusion/","page":"Conclusion","title":"Conclusion","text":"This marks the completion of my internship, this was an absolutely thrilling and exciting experience, I got the opportunity to learn a ton here, especially from my mentors Morten Piibeleht and Hetarth Shah.","category":"page"},{"location":"conclusion/","page":"Conclusion","title":"Conclusion","text":"I am eternally grateful to Google and Julia for giving me this opportunity to intern at such a prestigious organisation with such talented people.","category":"page"},{"location":"conclusion/","page":"Conclusion","title":"Conclusion","text":"I want to sincerely thank my mentors who supported me, helped me and guided me. I won't be able to do this without their support so thank you so much for your kindness.","category":"page"},{"location":"conclusion/","page":"Conclusion","title":"Conclusion","text":"I hope to be a part of this community and contribute to it with the best of my capabilities as much as I can.","category":"page"},{"location":"improving_tokenizer/#Updating-Tokenizer","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"","category":"section"},{"location":"improving_tokenizer/#Relevant-PR-:-[#2744](https://github.com/JuliaDocs/Documenter.jl/pull/2744)","page":"Updating Tokenizer","title":"Relevant PR : #2744","text":"","category":"section"},{"location":"improving_tokenizer/#Understanding-the-task","page":"Updating Tokenizer","title":"Understanding the task","text":"","category":"section"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"A tokenizer is a component of a search engine that processes text by breaking it down into smaller units called tokens. These tokens are then indexed and used to match search queries against the content.","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Right now the tokenize function in the repository in assets/html/js/search.js is :","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"    tokenize: (string) => string.split(/[\\s\\-\\.]+/)","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"It splits the string into tokens using regular expression that match spaces (\\s), hyphens (-), and dots (.) as delimiters. Consider somebody search for tasklocalstorage, a default tokenizer will split it into the following tokens “task”, “local”, “storage” While this works well for general text, it can cause problems when searching for programming related content, especially in languages like Julia where identifiers often contain underscores and are meant to be treated as a single cohesive unit.","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Some problems that can arise from this approach is :","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Loss of context\nReduced precision\nPoor user experience","category":"page"},{"location":"improving_tokenizer/#The-problem","page":"Updating Tokenizer","title":"The problem","text":"","category":"section"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"The old tokenizer was too simple and caused these issues:","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Problem 1: Lost Important Julia Syntax\nWhat happened when someone searched for \"Base.sort\": \"Base.sort function\" → [\"Base\", \"sort\", \"function\"]\nLost the connection between \"Base\" and \"sort\"\nWhy this is bad: Julia has special syntax like Base.sort where the dot (.) connects the module name to the function name. The old tokenizer split on dots, so it couldn't find \"Base.sort\" when you searched for it!\nProblem 2: Operators Got Lost\nWhen someone searched for \"^\" (power operator): \"Use ^ operator\" → [\"Use\", \"\", \"operator\"] The \"^\" symbol disappeared!\nProblem 3: Macros Broken Apart\nWhen someone searched for \"@time\" (a Julia macro): \"@time macro\" → [\"\", \"time\", \"macro\"] Lost the \"@\" symbol that makes it a macro!","category":"page"},{"location":"improving_tokenizer/#Solution","page":"Updating Tokenizer","title":"Solution","text":"","category":"section"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Change 1: Improving on the custom trimmer","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"right now the trimmer is :","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"  word = word\n    .replace(/^[^a-zA-Z0-9@!]+/, \"\")\n    .replace(/[^a-zA-Z0-9@!]+$/, \"\")","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Basically, what this is doing is removing every character which is not uppercase letters, lowercase letters, numbers, and two symbols '@' and '!' from the beginning and end of the query","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"but the problem is what if somebody search for just '^' it would result nothing","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"Change 2: Intelligent Pattern Matching\nI completely rewrote the tokenizer to understand Julia's special syntax. Here's what I did:","category":"page"},{"location":"improving_tokenizer/","page":"Updating Tokenizer","title":"Updating Tokenizer","text":"    // Julia-aware tokenization that preserves meaningful syntax elements\n    tokenize: (string) => {\n      const tokens = [];\n      let remaining = string;\n      \n      // Julia-specific patterns to preserve as complete tokens\n      const patterns = [\n        // Module qualified names (e.g., Base.sort, Module.Submodule.function)\n        /\\b[A-Z][A-Za-z0-9_]*(?:\\.[A-Z][A-Za-z0-9_]*)*\\.[a-z_][A-Za-z0-9_!]*\\b/g,\n        // Macro calls (e.g., @time, @async)\n        /@[A-Za-z_][A-Za-z0-9_]*/g,\n        // Type parameters (e.g., Array{T,N}, Vector{Int})\n        /\\b[A-Z][A-Za-z0-9_]*\\{[^}]+\\}/g,\n        // Function names with module qualification (e.g., Base.+, Base.:^)\n        /\\b[A-Z][A-Za-z0-9_]*\\.:[A-Za-z0-9_!+\\-*/^&|%<>=.]+/g,\n        // Operators as complete tokens (e.g., !=, &&, ||, ^, .=, ->)\n        /[!<>=+\\-*/^&|%:.]+/g,\n        // Function signatures with type annotations (e.g., f(x::Int))\n        /\\b[a-z_][A-Za-z0-9_!]*\\([^)]*::[^)]*\\)/g,\n        // Regular identifiers and function names\n        /\\b[A-Za-z_][A-Za-z0-9_!]*\\b/g,\n        // Numbers (integers, floats, scientific notation)\n        /\\b\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?\\b/g\n      ];\n      \n      // Apply patterns in order of specificity (most specific first)\n      for (const pattern of patterns) {\n        pattern.lastIndex = 0; // Reset regex state\n        let match;\n        while ((match = pattern.exec(remaining)) !== null) {\n          const token = match[0].trim();\n          if (token && !tokens.includes(token)) {\n            tokens.push(token);\n          }\n        }\n      }\n      \n      // Also split on common delimiters for any remaining content\n      const basicTokens = remaining.split(/[\\s\\-,;()[\\]{}]+/).filter(t => t.trim());\n      for (const token of basicTokens) {\n        if (token && !tokens.includes(token)) {\n          tokens.push(token);\n        }\n      }\n      \n      return tokens.filter(token => token.length > 0);\n    },","category":"page"},{"location":"key_bindings/#Navigate-the-Search-Results-using-up-and-down-keys","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"","category":"section"},{"location":"key_bindings/#Related-PR-:-[#2761](https://github.com/JuliaDocs/Documenter.jl/pull/2761)","page":"Navigate the Search Results using up and down keys","title":"Related PR : #2761","text":"","category":"section"},{"location":"key_bindings/#Initial-Approach","page":"Navigate the Search Results using up and down keys","title":"Initial Approach","text":"","category":"section"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"for this I created a custom event to reset keyboard navigation selection and will be sending this event through the document object in search.js","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"document.dispatchEvent(new CustomEvent(\"search-results-updated\"));","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"In assets/html/js/shortcut.js I updated the footer with instruction to toggle using up and down keys : ","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"<footer class=\"modal-card-foot is-flex is-justify-content-space-between is-align-items-center\">\n      <div class=\"is-flex gap-3 is-flex-wrap-wrap\">\n        <span>\n          <kbd class=\"search-modal-key-hints\">Ctrl</kbd> +\n          <kbd class=\"search-modal-key-hints\">/</kbd> to search\n        </span>\n        <span> <kbd class=\"search-modal-key-hints\">esc</kbd> to close </span>\n      </div>\n      <div class=\"is-flex gap-3 is-flex-wrap-wrap\">\n        <span>\n          <kbd class=\"search-modal-key-hints\">↑</kbd>\n          <kbd class=\"search-modal-key-hints\">↓</kbd> to navigate\n        </span>\n        <span> <kbd class=\"search-modal-key-hints\">Enter</kbd> to select </span>\n      </div>\n    </footer>","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"and the logic I used to render the change is to have a variable ","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"let selectedResultIndex = -1;","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"and added an event listener to update the whenver an up key or a down key is pressed and it increments or decrements the selectedResultIndex respectively and call the updatedSelectedResult()","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"const searchResults = document.querySelectorAll(\".search-result-link\");\n\n      if (event.key === \"ArrowDown\") {\n        event.preventDefault();\n        if (searchResults.length > 0) {\n          selectedResultIndex = (selectedResultIndex + 1) % searchResults.length;\n          updateSelectedResult(searchResults);\n        }\n      } else if (event.key === \"ArrowUp\") {\n        event.preventDefault();\n        if (searchResults.length > 0) {\n          selectedResultIndex = selectedResultIndex <= 0 ? searchResults.length - 1 : selectedResultIndex - 1;\n          updateSelectedResult(searchResults);\n        }\n      } else if (event.key === \"Enter\" && selectedResultIndex >= 0 && searchResults.length > 0) {\n        event.preventDefault();\n        searchResults[selectedResultIndex].click();\n      }","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"the updatedSelectedResult() change the highlighting from the previous selection to the current selection depending on the value of selectedResultIndex","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"function updateSelectedResult(searchResults) {\n    // Remove previous highlighting\n    searchResults.forEach(result => result.classList.remove('search-result-selected'));\n\n    // Add highlighting to current selection\n    if (selectedResultIndex >= 0 && selectedResultIndex < searchResults.length) {\n      const selectedResult = searchResults[selectedResultIndex];\n      selectedResult.classList.add('search-result-selected');\n      selectedResult.scrollIntoView({ block: 'nearest', behavior: 'smooth' });\n    }\n  }","category":"page"},{"location":"key_bindings/#Change-in-approach","page":"Navigate the Search Results using up and down keys","title":"Change in approach","text":"","category":"section"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"this was working but my mentor Hetarth Shah correctly mentioned that it is over-engineered in the sense that you already have a :focus element which you can use and avoid all these complexity.","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"I them implemented the :focus approach which honestly was much more simpler, clear and easy to read No creating custom event, no need of selectedResultIndex variable","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"just simply doing : ","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"if (searchResults.length > 0) {\n          const currentFocused = document.activeElement;\n          const currentIndex = Array.from(searchResults).indexOf(currentFocused);\n          const nextIndex = currentIndex < searchResults.length - 1 ? currentIndex + 1 : 0;\n          searchResults[nextIndex].focus();\n        }","category":"page"},{"location":"key_bindings/","page":"Navigate the Search Results using up and down keys","title":"Navigate the Search Results using up and down keys","text":"oh so beautiful and much more readable. Thank you Hetarth Shah","category":"page"},{"location":"listing_in_si/#Proper-listings-in-Search-Index","page":"Proper listings in Search Index","title":"Proper listings in Search Index","text":"","category":"section"},{"location":"creating_test_manual/#Creating-test-manual-and-testing-it-on-benchmarks","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"","category":"section"},{"location":"creating_test_manual/#Relevant-PR-:-[#2757](https://github.com/JuliaDocs/Documenter.jl/pull/2757)","page":"Creating test manual and testing it on benchmarks","title":"Relevant PR : #2757","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"My mentor suggested that it will be much more logical and understandable if we create a custom manual and seperate tests for it so that it is clear what we are testing and what expected docs should be ","category":"page"},{"location":"creating_test_manual/#Initializing","page":"Creating test manual and testing it on benchmarks","title":"Initializing","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"So I started by creating a new file edgecasequeries.jl which will have all the testcases, the same struct ","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"struct TestQuery\n    query::String\n    expected_docs::Vector{String}\nend","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"and then I start writing tests, I wrote tests for ","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"content queries that would be considered atypical\nqueries for structural cases\nqueries for markdown\nqueries for common words\nautodocs queries\ncross reference queries\ndoctests queries\ntable queries","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"now in evaluate.jl and real_search.jl, I have to do changes in the existing functions so that it takes in the search index path as we will now send different search indexes one for this edge case and one for the original documenter docs","category":"page"},{"location":"creating_test_manual/#Running-both-the-benchmarks","page":"Creating test manual and testing it on benchmarks","title":"Running both the benchmarks","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"I created a new file run_all_benchmarks.jl which just run the run_benchmarks.jl once for documenter docs and once for the new tests","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"println(\"Running all benchmarks...\")\n\nprintln(\"\\nRunning benchmarks for default search index...\")\nrun(`julia $(@__DIR__)/run_benchmarks.jl $(@__DIR__)/../../docs/build/search_index.js all_test_queries`)\n\nprintln(\"\\nRunning benchmarks for edge case search index...\")\nrun(`julia $(@__DIR__)/run_benchmarks.jl $(@__DIR__)/../search_edge_cases/build/search_index.js edge_case_queries`)\n\nprintln(\"\\nAll benchmarks complete.\")","category":"page"},{"location":"creating_test_manual/#Creating-different-modules-on-which-to-test","page":"Creating test manual and testing it on benchmarks","title":"Creating different modules on which to test","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"I created a seperate directory test/search_edge_cases to have all the related file, it has a simple make.jl which looks like this","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"using Documenter\n\nmakedocs(\n    root = @__DIR__,\n    sitename = \"Search Edge Case Tests\",\n    format = Documenter.HTML(\n        prettyurls = false,\n    ),\n    pages = [\n        \"Home\" => \"index.md\",\n        \"Atypical Content\" => \"atypical_content.md\",\n        \"Structural Cases\" => \"structural_cases.md\",\n        \"Markdown Syntax\" => \"markdown_syntax.md\",\n        \"Common Words\" => \"common_words.md\",\n    ],\n    build = \"build\",\n)","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"then created a src directory and created md files for testing purposes","category":"page"},{"location":"creating_test_manual/#Added-in-the-CI-also","page":"Creating test manual and testing it on benchmarks","title":"Added in the CI also","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"We want to run both of these benchmarks in the CI so I added this in the CI.yml file","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"- name: Build search edge cases documentation  \n  run: |\n    cd test/search_edge_cases\n    julia --project=. -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=\"../../\"))'\n    julia --project=. make.jl","category":"page"},{"location":"creating_test_manual/#Changes-in-the-Makefile","page":"Creating test manual and testing it on benchmarks","title":"Changes in the Makefile","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"change the makefile to run the run_all_benchmarks.jl instead of running run_benchmarks.jl","category":"page"},{"location":"creating_test_manual/#Reference-values-for-the-test_edge_cases.jl","page":"Creating test manual and testing it on benchmarks","title":"Reference values for the test_edge_cases.jl","text":"","category":"section"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"In test/search/edgecasebenchmark_reference.json I added the reference values based on which we will see if any changes in the search index has improved the search relevance or has made it worse","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"{\n  \"average_precision\": 37.7,\n  \"average_recall\": 83.2,\n  \"average_f1_score\": 43.1\n}","category":"page"},{"location":"creating_test_manual/","page":"Creating test manual and testing it on benchmarks","title":"Creating test manual and testing it on benchmarks","text":"these are the values I got when I run it for the first time, it's only going to get better from here (hopefully!!!)","category":"page"},{"location":"warn_when_si_big/#Warn-when-the-search-index-is-too-big","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"","category":"section"},{"location":"warn_when_si_big/#Relevant-PR-:-[#2753](https://github.com/JuliaDocs/Documenter.jl/pull/2753)","page":"Warn when the search index is too big","title":"Relevant PR : #2753","text":"","category":"section"},{"location":"warn_when_si_big/#Finding-the-threshold","page":"Warn when the search index is too big","title":"Finding the threshold","text":"","category":"section"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"As discussed in #2423 that we should warn when the search index is too big as are already warning if the HTML files are too big","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"Initial problem was deciding on the threshold size for warning, so my mentor suggested that I look at some common repo's search indexes to find the mean search index size","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"here are some search index sizes for documentation of common Julia repo's","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"Julia - 993KB\nDocumenter - 115KB\nIJulia - 16Kb\nPolymake.jl - 12.4KB\nDifferentialEquations.jl - 175 kb\nEnzyme.jl - 43.2 kb\nOceananigans.jl - 239 kb\nSymbolics.jl - 42.4 kb\nModelingToolkit.jl - 136 kb","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"Initially I thought we should give a warning and also an error if the size if too big, but then asinghvi17 mentioned that error will stop users from building large docs and we don't want that so we will only give a warning and not an error.","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"we end up with 500 kb as a threshold for warning the user that the search index size is getting a little too big","category":"page"},{"location":"warn_when_si_big/#Implementation","page":"Warn when the search index is too big","title":"Implementation","text":"","category":"section"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"I implemented this code in HTMLWriter.jl as the previous warnings are also there only ","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"I created a new variable search_size_threshold_warn::Int and initialized it with 500 * 2^10 (500 KiB)","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"and created a single if condition","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"let file_size = filesize(search_index_path)\n        if file_size > settings.search_size_threshold_warn\n            file_size_format_results = format_units(file_size)\n            size_threshold_warn_format_results = format_units(settings.search_size_threshold_warn)\n            @warn \"\"\"\n            Generated search index over size_threshold_warn limit:\n                Generated file size: $(file_size_format_results)\n                search_size_threshold_warn: $(size_threshold_warn_format_results)\n                Search index file:   $(search_index_path)\n            \"\"\"\n        end","category":"page"},{"location":"warn_when_si_big/","page":"Warn when the search index is too big","title":"Warn when the search index is too big","text":"and we are all done!!!","category":"page"},{"location":"adding_search_benchmarks/#Adding-Search-Benchmarks","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"","category":"section"},{"location":"adding_search_benchmarks/#Relevant-PR-:-[#2740](https://github.com/JuliaDocs/Documenter.jl/pull/2740)","page":"Adding Search Benchmarks","title":"Relevant PR : #2740","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"We had our first meeting, and we discussed what would be the flow of the entire internshiop and also discussed how to go about the first deliverable as per the proposal which is Adding Search Benchmarks.  ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"We discussed what should be the language of choice for writing scripts for benchmarking, we had two possible candidates, one was Julia (for obvious reasons, since the whole repo is in Julia) and the other one was JavaScript since the search functionality is implemented in JavaScript so it would be easier to interact with the search functionality.  ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"We talked about it and thought of JavaScript as a better choice but now I think of it, I belive the barebone architecture for benchmarks should be in Julia only so that in future if anybody want to add more benchmarks or new tests they can do it easily as I am expecting most of the people coming in the Documenter repo are coming from Julia background and as far as interacting to the JavaScript based search functionality we can see how to do it through Julia in coming days.","category":"page"},{"location":"adding_search_benchmarks/#Creating-query-structure","page":"Adding Search Benchmarks","title":"Creating query structure","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"First we'll create a new directory in test folder, I have named it search. Inside it I have created the first file named test_queries.jl","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"The file structure look like this :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"test/\n├─search/\n│   └─test_queries.jl\n...","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"I started with creating a basic struct which stores the search query and what should be the expected docs in the following manner :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"struct TestQuery\n    query::String\n    expected_docs::Vector{String}\nend","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"we can then compare it with the actual result and find out the different benchmarks.","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Now we can create different groups of queries like basic queries or queries specific to Julia syntax and if anybody from the community want to test some queries specific to their usecase, they can do it easily. We can then use them all together using something like vcat which will concatenate all the arrays into one","category":"page"},{"location":"adding_search_benchmarks/#Evaluation","page":"Adding Search Benchmarks","title":"Evaluation","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"For now, I am using three metrics for calculating benchmarks namely :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Precision \nmeasures how many of the returned results are relevant.\nExample: if you returned 5 docs, out of which 3 are relevant, precision = 3/5 = 0.6.\nRecall \nmeasures how many of the true relevant documents were found in the result.\nExample: if there were 4 relevant docs and you returned 3 of them, recall = 3/4 = 0.75.\nF1 Score \nharmonic mean of precision and recall.\nthis balances precision and recall in a single number.\nF_1 = 2 times fractextprecision times textrecalltextprecision + textrecall","category":"page"},{"location":"adding_search_benchmarks/#Helper-functions","page":"Adding Search Benchmarks","title":"Helper functions","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Now let's create a function that evaluate all these metrics for a single query","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"It'll look something like this :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"function evaluate_query(search_function, query::TestQuery)\n    results = search_function(query.query)\n\n    precision = calculate_precision(results, query.expected_docs)\n    recall = calculate_recall(results, query.expected_docs)\n    f1 = calculate_f1(precision, recall)\n\n    return Dict(\n        \"query\" => query.query,\n        \"precision\" => precision,\n        \"recall\" => recall,\n        \"f1\" => f1,\n        \"expected\" => query.expected_docs,\n        \"actual\" => results\n    )\nend","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"This will return a dictionary that have all the relevant results. We still have to create the search function that will search the query in our actual search implementation.","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"This looks good, now we need to create a function that evaluate all metrics for a suite of queries, which would essentially be calling the evaluate_query function for array of queries, and then calculating the mean of all results for each metric and return a dictionary similar to evaluate_query function","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"It look something like this : ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"function evaluate_all(search_function, queries)\n    results = [evaluate_query(search_function, q) for q in queries]\n\n    avg_precision = mean([r[\"precision\"] for r in results])\n    avg_recall = mean([r[\"recall\"] for r in results])\n    avg_f1 = mean([r[\"f1\"] for r in results])\n\n    return Dict(\n        \"individual_results\" => results,\n        \"average_precision\" => avg_precision,\n        \"average_recall\" => avg_recall,\n        \"average_f1_score\" => avg_f1\n    )\nend","category":"page"},{"location":"adding_search_benchmarks/#The-Meeting-#2","page":"Adding Search Benchmarks","title":"The Meeting #2","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"We had our weekly meeting and there were few suggested edits which we are going to implement :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"use struct instead of dictionary to return the search results.\njust display the overall result in the terminal and rest all of the detailed results should be written in a text file.\nthe returning struct should also contain integers like total_documents_retrieved, total_relevant_found along with float. \nWrite short, descriptive comments explain the code\nmy mentors has advised me to open a pr, so that other people can see and give their suggestions on the work done till now how here the open pr link : PR Link","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"We have now created this struct for a single search query ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"struct QueryResult\n    query::String\n    precision::Float64\n    recall::Float64\n    f1::Float64\n    expected::Vector{String}\n    actual::Vector{String}\n    # Raw integer values used in calculations\n    relevant_count::Int  # Number of relevant documents found\n    total_retrieved::Int  # Total number of documents retrieved\n    total_relevant::Int   # Total number of relevant documents\nend","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"and one for multiple search queries","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"struct EvaluationResults\n    individual_results::Vector{QueryResult}\n    average_precision::Float64\n    average_recall::Float64\n    average_f1_score::Float64\n    # Raw integer values for overall evaluation\n    total_relevant_found::Int    # Total number of relevant documents found across all queries\n    total_documents_retrieved::Int  # Total number of documents retrieved across all queries\n    total_relevant_documents::Int   # Total number of relevant documents across all queries\nend","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"also I have done relevant changes to the previously made functions and now from each function we are returning values with the struct only, much more robust!","category":"page"},{"location":"adding_search_benchmarks/#Printing-the-Benchmarks","page":"Adding Search Benchmarks","title":"Printing the Benchmarks","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"we are writing the overall results in the cli and the detailed results are written in a file which would be named : searchbenchmarkresultsyyyy-mm-ddHH-MM-SS.txt, where the placeholders will be filled by the date and time when that file was build.","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"right now we are just displaying it as it is but my maintainer has suggested to use a Julia package named PrettyTables.jl","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"right now this is how the results in CLI are looking ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"(Image: CLI Output)","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"we can definitely make it prettier using PrettyTable.jl","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"and now after using the PrettyTable.jl package, it is looking like this : ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"(Image: CLI Output new)","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Looking much better! (IMO Obviously)","category":"page"},{"location":"adding_search_benchmarks/#Imitating-the-Search","page":"Adding Search Benchmarks","title":"Imitating the Search","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Now since we want to search for the query and compare it with the expected result we want to imitate the search functionality originally implemented in the Documenter which uses the minisearch engine","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so the steps would look like :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Loading the search index\nInstall the minisearch using npm\nWriting the js code to use the minisearch engine\nRun the code\nReturn the results as actual docs for comparison with expected docs","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Let's start with loading the search index. Now we have thought of multiple ways of going about this, the main challenge was where should we get the search index from, our options are :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"using the search index built during the test process :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"search_index_path = joinpath(@__DIR__, \"../examples/builds/html/search_index.js\")","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"using the actual search index built during the build process of the Documenter documentation","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"    search_index_path = joinpath(@__DIR__, \"../../docs/build/search_index.js\")","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"I have gone with the later, since if we use the search index that is used in production we can do more thorugh testing","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so the whole function now look like this : ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"    # Load the real search index from test examples (already built!)\n    function load_real_search_index()\n        # Use the example search index that's already built and tested\n        search_index_path = joinpath(@__DIR__, \"../../docs/build/search_index.js\")\n\n        if !isfile(search_index_path)\n            error(\"Search index not found at: $search_index_path\")\n        end\n\n        # Read and parse the JavaScript file\n        content = read(search_index_path, String)\n\n        # Find the JSON data after \"var documenterSearchIndex = \"\n        json_start = findfirst(\"var documenterSearchIndex = \", content)\n        if json_start === nothing\n            error(\"Invalid search index format: missing variable declaration\")\n        end\n\n        # Extract JSON content (everything after the variable declaration)\n        json_content = content[(last(json_start) + 1):end]\n\n        # Parse the JSON\n        parsed = JSON.parse(json_content)\n        return parsed[\"docs\"]  # Return just the docs array\n    end","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"if the file doesn't exist we throw an error, else we read the file using the read function available in Julia, now the search index file has structure like this : ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"var documenterSearchIndex = {\"docs\":[{\"location\":\"linenumbers/#@repl,-@example,-and-@eval-have-correct-LineNumberNodes-inserted\",\"page\":\"@repl, @example, and @eval have correct LineNumberNodes inserted\"...}]","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so we access the search index by removing the var documenterSearchIndex = part by storing its last index and we store everything after that in json_content array, then we parse it using JSON.parse and from it return the value of parsed[\"docs\"] to finally get the complete search index in JSON format.","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Now we'll install the minisearch using npm for this we just did created a package.json and added minisearch as a dependency, here a little hiccup came since I initially used ^6.1.0 for the version but my mentors advised to use the exact version which is getting used in the Documenter which is 6.1.0 so I fixed it, here's what the package.json looks like:","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"{\n\"name\": \"documenter-search-benchmark\",\n\"version\": \"1.0.0\",\n\"description\": \"Search benchmarking for Documenter.jl\",\n\"dependencies\": {\n    \"minisearch\": \"^6.1.0\"\n}\n}","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"next step, we'll be writing the JS code to use the minisearch engine Now my initial thought would be that this is a piece of cake, just call the search functionality already implemented in assets/html/js/search.js and we are good to go but what I didn't realize is that they both have different execution environments, the original search functionality is designed for the browser, where ours is a Julia script, it runs in a command line environment using Node.js as a subprocess to execute JavaScript. so now we have two options :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Replicate the core logic\nPros : no new dependence\nCons : Violates DRY\nIsolate the pure search logic in another file and then call it in both the places assets/html/js/search.js and test/search/real_search.jl\nPros : Obeys the DRY principle\nCons : have to add a new build tool to a primarily Julia project","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"I did gave a try to the second option but finally I have gone with the first approach as it is more simple and since it is primarily a Julia project I don't want to add unnecessary JS dependencies in it.","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so initially I created a string only with all the JS code and named it wrapper_js and just read it, but that end up becoming a very big string so my mentor suggested to have a seperate .js file and read it from there so we are doing that and injecting data using placeholders so now we don't have to spin the full browser to test the search functionality, which would be much slower","category":"page"},{"location":"adding_search_benchmarks/#Adding-Make-Command","page":"Adding Search Benchmarks","title":"Adding Make Command","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"My mentor suggested to add a make command that run these tests, I named it search-benchmarks","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"the command is pretty simple : ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"search-benchmarks:\n\t${JULIA} --project test/search/run_benchmarks.jl","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"added ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"rm -f test/search/search_benchmark_results_*.txt","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"to the clean command","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"and added the search-benchmarks command to the PHONY so it doesn't interpret it as a file rather than a command","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":".PHONY: default docs-instantiate themes help changelog docs test search-benchmarks","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"and finally added this","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"@echo \" - make search-benchmarks: run search functionality benchmarks\"","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"in the help command to tell the people what does the command do","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"and now our command works like a charm!","category":"page"},{"location":"adding_search_benchmarks/#Running-Benchmarks-on-CI","page":"Adding Search Benchmarks","title":"Running Benchmarks on CI","text":"","category":"section"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"My mentor asked to add a simple CI job that run these benchmarks, so I created a Github Actions workflow, named it Benchmarks (quite creative!) ","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so whenever code is pushed to the master repo, or when someone opens a pull request or when it is triggered manually and ensuring only one workflow run at a time using concurrency for the same branch or pull request it does :","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"Checkouts the code \nSetup Julia\nCache the Julia packages\nBuild Julia packages\nRun Benchmarks","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"After I showed it to my mentor he suggested to also upload the full benchmark output as an artifact which can be downloaded by anybody, great idea!","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"but later he suggested a much better idea, earlier I had a seperate CI job named benchmark.yml so he suggested to not make a seperate job rather put this in the old CI.yml and make it depend on the main suite where the manual is build anyway so we could upload that from the CI run and then download that into this benchmarking job, so we don't have to rebuild the manual for benchmark again","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so this is what the final job looks like inside CI.yml","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"benchmarks:\n    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }}\n    runs-on: ${{ matrix.os }}\n    needs: docs\n    strategy:\n      fail-fast: false\n      matrix:\n        version:\n          - '1'\n        os:\n          - ubuntu-latest\n        arch:\n          - x64\n    steps:\n      - uses: actions/checkout@v4\n      - uses: julia-actions/setup-julia@v2\n        with:\n          version: ${{ matrix.version }}\n          arch: ${{ matrix.arch }}\n          show-versioninfo: true\n      - uses: julia-actions/cache@v2\n      - uses: julia-actions/julia-buildpkg@v1\n      - name: Download search index\n        uses: actions/download-artifact@v4\n        with:\n          name: search-index\n          path: docs/build\n      - name: Build test examples\n        shell: julia --color=yes --project=test/examples {0}\n        run: |\n          using Pkg\n          Pkg.instantiate()\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20.x'\n      - name: Install Node.js dependencies\n        run: npm install\n        working-directory: test/search\n      - name: Run search benchmarks\n        run: make search-benchmarks\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      - name: Upload search benchmark results\n        uses: actions/upload-artifact@v4\n        with:\n          name: search-benchmark-results\n          path: test/search/search_benchmark_results_*.txt","category":"page"},{"location":"adding_search_benchmarks/","page":"Adding Search Benchmarks","title":"Adding Search Benchmarks","text":"so now in CI the test are running taking the search index from the previous CI and then giving the ability to download the detailed benchmark report. Neat!","category":"page"},{"location":"#Improving-Search-functionality-for-Documenter.jl","page":"Home","title":"Improving Search functionality for Documenter.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This site is a collection of notes, progress reports for the 2025 Google Summer of Code (GSoC) project by @Rahban1, mentored by @mortenpi and @Hetarth02.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I thought it would be a good idea to document my journey using Documenter itself, also I was inspired by my mentor Morten who did the same :)","category":"page"}]
}
